Modifies: pause()
Adds:     sync() {}, atomic {}, fork() and synchronized/atomic methods.

NOTE: I havn't fully decided what to do with multitasking, I may use
      one of the new multithreaded libraries and rewrite using it
      instead...

* Overview

A frame is the execution state of a ColdC method.  The current frame is
only relative to the current method, beginning execution within a new
frame uses a new frame context.  ColdC ticks are contained within each
frame, rather than in a global context.  A task is a stack of methods
executing in relation to each other (one after another).

* Outline

Preemptive multi-tasking will be based upon either CPU ticks or ColdC
ticks (have not decided which).  CPU ticks give the advantage of also
taking native functions into consideration.  However, this will also
cause tasks to be preempted faster on a loaded machine.

When a certain threshold has been reached, the task will be preempted
(suspended) and added to a list of preempted tasks, to continue
execution at a later time.  Being preempted also refreshes the current
frame's ticks.

* Synchronizing

Synchronization is the act of a task gaining absolute control of an
object.  Only one task can be synchronized with an object at any given
time.  There are two ways of synchronizing with an object.  First, one
can implicitly synchronize the method with an object by adding the
synchronized method flag.  Or the block statement 'sync' can be used,
which accepts a list of objects and contains a block of code to execute
while synchronized to the object(s), such as:

NOTE: wrong, I want to give the ability to specify read/write sync,
      read is non blocking to other tasks, write blocks all other tasks.
      Furthermore, have the object lists inclusive by level...

      Possible syntaxes:

#1:

sync (object^read, object^write) { ... }

#2:

sync(obj_1, 'read);
sync(obj_2, 'write);   // read is implied with write
sync(obj_3, 'read);

...

unsync(obj_1);
unsync(obj_2);
unsync(obj_3);

#3:

sync ([[object, 'read], [object, 'write]..]) { ... }

#4:

sync {
    with(obj_1, 'read);
    with(obj_2, 'write);   // read is implied with write
    with(obj_3, 'read);
} when {

}

#5:

sync ($obj_1 : 'read, $obj_2 : 'write, $obj_3 : 'read) { ... }

#6:

sync ($obj_1&read, $obj_2&write, $obj_3&read) { ... }

Frankly, I dont like any of these, although I do like #5 a little, it
just doesn't feel right. I actually like #6 a little better, but its
still not feeling right...

sync ... {
    while (times) {
        .call_synced_method();
        times = times - 1;
    }
}

we could do it totally different, and have 'read' and 'write' instead
of 'sync', ala:

read (this()) {
    ...
}

write (this()) {
    ...
}

read (obj_1) {
    write (obj_1, obj_2) {
        ...
    }
    ...
}

When a task is synchronized with an object, it has full read/write
ability to any object variables it can access.  Synchronized tasks
can be preempted, just like unsynchronized tasks (preemptiveness is
defined by the atomic state).

Furthermore, the synchronization is cooperative througout the tasks.
If a synchronized frame calls a method which must be synchronized, it is
not blocked.

If a synchronize call is made, and the task is unable to synchronize
with the object, it may be blocked (if it is not atomic).  Blocked tasks
are suspended, and added to a list for that object.  When the current
task synchronizing to the object releases it's hold, the first task
in the blocked list is executed.

If an atomic task is blocked, the error ~blocked is thrown.

* Atomic code blocks

NOTE: Atomic code may not be used...

If a frame is preempted, blocked or suspended while it is set as atomic,
the error ~preempted, ~blocked or ~suspended is thrown.  The atomic
state is propogated through subsequent frames in the task, so that if a
frame becomes atomic, while it is atomic any frames deeper into the
task from it become atomic.

Frames become atomic by either setting the atomic method flag, or by
using the block statement 'atomic' in ColdC code.  Examples:

atomic .do_this();

atomic {
    .do_this();
    .do_that();
}

* Function refresh()

This function basically acts as the existing pause().  When called
it does not always preempt the task.  Infact, it will only preempt
_if_ the task is nearly out of ticks.  It can be called with a tick
threshold (default ~500 or so).  If the task is less than this
threshold, it will preempt, thereby refreshing the tick count.

* Function pause()

pause() gives the ability to cooperatively multitask.  It will have
an optional flag which can be passed (1 or 0), if it is true (1) then
pause() will act nicely, if it is false (default, 0) it will not act
nicely.

When pause() is called it will instantly preempt the task, unless it
is within an atomic block.  If it is within an atomic block and is a
nice pause, the task will continue to run until it either runs out of
frame ticks or it reaches the end of the atomic block.  If it runs out
of ticks, the usual error is thrown (~ticks).  If it reaches the end of
the atomic block it instantly preempts.

* Function fork() 

NOTE: I'm probably going to just have 'fork' as a method flag, and you
      can call methods which implicitly fork off, this is an easier
      concept for people to handle than blocks of code which fork.

fork() splits a task.  When called it splits the task into two exact
frames.  The function fork() has a logical expression value of 0 to the
child process, and the value is the forked task id for the parent
task.

An optional delay argument may be supplied to fork, defaulting to 0.
The delay specifies how long to wait before beginning execution of the
child task.

Notes: possibly have a MAX_FORK for each task; possibly have a method
flag of 'fork', where if that method is called it starts its own
execution task, rather than becoming a part of the current task.
The logical expression value of a forked method is it's task_id.

