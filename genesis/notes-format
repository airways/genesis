
ColdCC format, broken into directives, once 'object' is defined, it is
always assumed that directives are in respect to that object, using
directives without specifying an object will result in an error.

ColdCC will use heuristic rules in deciding how to handle each
directive.  For instance, stating an object, followed by a method
definition would assume that the object already exists and has parents,
and that you are simply recompiling the method or changing the method
flags.  The keywords 'new' and 'old' can be used in some places to state
whether the directive is in regard to a new object, or old object ('old'
is primarily used with 'object' to state that an object should be
destroyed).

Also, with this new format, newlines (ascii 10) are included as
whitespace.

The following uses a pseudo BNF format, with some regexp twists,
whitespace is assumed to be seperating words.

ident          = [a-z][a-z_0-9]*
name           = ident ["~" ident]
object         = ("#" [0-9]+) | ("$" ident)
action         = ("new" | "old")
access         = ("root" | "driver" | "public" | "protected" | "private")

obj_cmd        = [action] "object" object [":" parent [, parents...]] ";"

Examples:        old object $test_user;
                 object $foo: $user, $help_ui, $interaction;

    Define the object, $name and #num are acceptable, if $name exists
    it uses the next available #num and assigns $name to that #num.
    Furthermore the keyword 'new' or 'old' can be used.  Stating 'new'
    will let the compiler know that it should be a new object, possibly
    altering some heuristic rules.  Stating 'old' will destroy the
    object, if it exists.

parent_cmd     = [action] "parent" object ";"

Examples:        parent $bar;
                 old parent $baz;

    Define parents for object.  If neither 'new' or 'old' are defined,
    it adds them to the parents list as if it were a set.  'new' is
    treated the same way, for now.  'old' will remove the parent from
    the parents list.

var_cmd        = [action] "var" [definer] ident ["=" data] ";"

Examples:        old var $obj foo;
                 var text = [];

    This sets or defines an object variable.  object represents the
    definer, if the definer is not specified it defaults to the current
    object.  data represents any valid ColdC data.  data is not
    required.  Specifying 'old' will either clear the variable, if it
    is not defined on this object, or will remove the variable, if this
    is the defining object.

flags         = "locked" "nooverride" "synchronized" "forked" "native"
method_cmd    = [action] [access] "method" [definer ["."]] name [":" flags] [code] ";"

Examples:

old method $obj foo_cmd;

protected method $thisobj foo_cmd: locked, nooverride {
    arg cmd, cmdstr, [args];
    var x;

    return x;
}

    This allows you to define various aspects of a method, and possible
    even define the method itself.  Furthermore, you can specify renamed
    methods in the method name by seperating the old name from the new
    name with a tilde.  This is useful when protecting native methods.
    For instance, if the native method 'status' was initialized as:

public method status: native;

    And you wanted to protect it, but still have it be a native methods
    accross restarts.  You would change it to be 'private', rename it,
    and create an accessor method.  The final saved format would be:

private method status~_status: native;
public method status: nooverride {
    (> .perms(...) <);
    return ._status();
}

    Renamed methods are only stored online, in respect to native methods.
